<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SyntaxTutor: SLR1Parser Class Reference</title>
<link rel="icon" href="syntaxtutor.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SyntaxTutor
   </div>
   <div id="projectbrief">Educational app designed to help compiler students understand LL(1) and SLR(1) parsing algorithms.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classSLR1Parser.html','','classSLR1Parser-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">SLR1Parser Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements an SLR(1) parser for context-free grammars.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="slr1__parser_8hpp_source.html">slr1_parser.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for SLR1Parser:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser__coll__graph.png" border="0" usemap="#aSLR1Parser_coll__map" loading="lazy" alt="Collaboration graph"/></div>
<map name="aSLR1Parser_coll__map" id="aSLR1Parser_coll__map">
<area shape="rect" title="Implements an SLR(1) parser for context&#45;free grammars." alt="" coords="10,207,105,234"/>
<area shape="rect" href="structGrammar.html" title="Represents a context&#45;free grammar, including its rules, symbol table, and starting symbol." alt="" coords="16,106,99,134"/>
<area shape="poly" title=" " alt="" coords="60,149,60,206,55,206,55,149"/>
<area shape="rect" href="structSymbolTable.html" title="Stores and manages grammar symbols, including their classification and special markers." alt="" coords="5,5,110,33"/>
<area shape="poly" title=" " alt="" coords="60,49,60,105,55,105,55,49"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:s_5Faction" id="r_s_5Faction"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSLR1Parser_1_1s__action.html">s_action</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ada5e4f3519f68c6b1857742b016c0895" id="r_ada5e4f3519f68c6b1857742b016c0895"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada5e4f3519f68c6b1857742b016c0895">Action</a> { <a class="el" href="#ada5e4f3519f68c6b1857742b016c0895a825a3d98017bab11815ad2817201324c">Shift</a>
, <a class="el" href="#ada5e4f3519f68c6b1857742b016c0895aec4875f03ff0bb0b26cf76ac7f41e3c8">Reduce</a>
, <a class="el" href="#ada5e4f3519f68c6b1857742b016c0895ac4408d335012a56ff58937d78050efad">Accept</a>
, <a class="el" href="#ada5e4f3519f68c6b1857742b016c0895ace2c8aed9c2fa0cfbed56cbda4d8bf07">Empty</a>
 }</td></tr>
<tr class="memdesc:ada5e4f3519f68c6b1857742b016c0895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the possible actions in the SLR(1) parsing table.  <a href="#ada5e4f3519f68c6b1857742b016c0895">More...</a><br /></td></tr>
<tr class="memitem:a8eae4c68e04f33947c69190bacd1a3bd" id="r_a8eae4c68e04f33947c69190bacd1a3bd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8eae4c68e04f33947c69190bacd1a3bd">action_table</a></td></tr>
<tr class="memdesc:a8eae4c68e04f33947c69190bacd1a3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the action table for the SLR(1) parser.  <br /></td></tr>
<tr class="memitem:ab5eb4bb9299e7fc800a95a23910f5217" id="r_ab5eb4bb9299e7fc800a95a23910f5217"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5eb4bb9299e7fc800a95a23910f5217">transition_table</a></td></tr>
<tr class="memdesc:ab5eb4bb9299e7fc800a95a23910f5217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the transition table for the SLR(1) parser.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af61cf9a5210b5df543a0ffcff96ce295" id="r_af61cf9a5210b5df543a0ffcff96ce295"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af61cf9a5210b5df543a0ffcff96ce295">SLR1Parser</a> ()=default</td></tr>
<tr class="memitem:aa42411d1cb318041138b476e80aacc9a" id="r_aa42411d1cb318041138b476e80aacc9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa42411d1cb318041138b476e80aacc9a">SLR1Parser</a> (<a class="el" href="structGrammar.html">Grammar</a> gr)</td></tr>
<tr class="memitem:af1f26efc1c4f8826b2bd1477aa44868b" id="r_af1f26efc1c4f8826b2bd1477aa44868b"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; <a class="el" href="structLr0Item.html">Lr0Item</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1f26efc1c4f8826b2bd1477aa44868b">AllItems</a> () const</td></tr>
<tr class="memdesc:af1f26efc1c4f8826b2bd1477aa44868b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves all LR(0) items in the grammar. This function returns a set of all LR(0) items derived from the grammar's productions. Each LR(0) item represents a production with a marker indicating the current position in the production (e.g., \( A \rightarrow \alpha \bullet \beta \)).  <br /></td></tr>
<tr class="memitem:a0ff2187985600bff50ff8235543d96fb" id="r_a0ff2187985600bff50ff8235543d96fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ff2187985600bff50ff8235543d96fb">Closure</a> (std::unordered_set&lt; <a class="el" href="structLr0Item.html">Lr0Item</a> &gt; &amp;items)</td></tr>
<tr class="memdesc:a0ff2187985600bff50ff8235543d96fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the closure of a set of LR(0) items.  <br /></td></tr>
<tr class="memitem:a00101890c3c4d2871a8c100209abf122" id="r_a00101890c3c4d2871a8c100209abf122"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00101890c3c4d2871a8c100209abf122">ClosureUtil</a> (std::unordered_set&lt; <a class="el" href="structLr0Item.html">Lr0Item</a> &gt; &amp;items, unsigned int size, std::unordered_set&lt; std::string &gt; &amp;visited)</td></tr>
<tr class="memdesc:a00101890c3c4d2871a8c100209abf122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for computing the closure of LR(0) items.  <br /></td></tr>
<tr class="memitem:aee48bcbf0a93badeb5271a7299cc458b" id="r_aee48bcbf0a93badeb5271a7299cc458b"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; <a class="el" href="structLr0Item.html">Lr0Item</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee48bcbf0a93badeb5271a7299cc458b">Delta</a> (const std::unordered_set&lt; <a class="el" href="structLr0Item.html">Lr0Item</a> &gt; &amp;items, const std::string &amp;str)</td></tr>
<tr class="memdesc:aee48bcbf0a93badeb5271a7299cc458b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the GOTO transition ( \(\delta\)) for a given set of LR(0) items and a symbol. This function is equivalent to the \(\delta(I, X)\) function in LR parsing, where it computes the set of items reached from a state \(I\) via symbol \(X\).  <br /></td></tr>
<tr class="memitem:a6a31a57223b052028c74f5d70db41c16" id="r_a6a31a57223b052028c74f5d70db41c16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a31a57223b052028c74f5d70db41c16">SolveLRConflicts</a> (const <a class="el" href="structstate.html">state</a> &amp;st)</td></tr>
<tr class="memdesc:a6a31a57223b052028c74f5d70db41c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves LR conflicts in a given state.  <br /></td></tr>
<tr class="memitem:a02df38d4f96383ea85d23f56472c57a0" id="r_a02df38d4f96383ea85d23f56472c57a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02df38d4f96383ea85d23f56472c57a0">First</a> (std::span&lt; const std::string &gt; rule, std::unordered_set&lt; std::string &gt; &amp;result)</td></tr>
<tr class="memdesc:a02df38d4f96383ea85d23f56472c57a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the FIRST set for a given production rule in a grammar.  <br /></td></tr>
<tr class="memitem:af0a486daf0c5083b113e557d68732481" id="r_af0a486daf0c5083b113e557d68732481"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0a486daf0c5083b113e557d68732481">ComputeFirstSets</a> ()</td></tr>
<tr class="memdesc:af0a486daf0c5083b113e557d68732481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the FIRST sets for all non-terminal symbols in the grammar.  <br /></td></tr>
<tr class="memitem:a06a9888464cfe48152d72311e25ad79a" id="r_a06a9888464cfe48152d72311e25ad79a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06a9888464cfe48152d72311e25ad79a">ComputeFollowSets</a> ()</td></tr>
<tr class="memdesc:a06a9888464cfe48152d72311e25ad79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the FOLLOW sets for all non-terminal symbols in the grammar. The FOLLOW set of a non-terminal symbol A contains all terminal symbols that can appear immediately after A in any sentential form derived from the grammar's start symbol. Additionally, if A can be the last symbol in a derivation, the end-of-input marker (<span class="tt">\$</span>) is included in its FOLLOW set. This function computes the FOLLOW sets using the following rules:  <br /></td></tr>
<tr class="memitem:af2549ef0375afbb8fd53fa2abafe60bb" id="r_af2549ef0375afbb8fd53fa2abafe60bb"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2549ef0375afbb8fd53fa2abafe60bb">Follow</a> (const std::string &amp;arg)</td></tr>
<tr class="memdesc:af2549ef0375afbb8fd53fa2abafe60bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the FOLLOW set for a given non-terminal symbol in the grammar.  <br /></td></tr>
<tr class="memitem:a95d3b55554e24aa03f6a73d7b895e78b" id="r_a95d3b55554e24aa03f6a73d7b895e78b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95d3b55554e24aa03f6a73d7b895e78b">MakeInitialState</a> ()</td></tr>
<tr class="memdesc:a95d3b55554e24aa03f6a73d7b895e78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the initial state of the parser's state machine.  <br /></td></tr>
<tr class="memitem:acdc3a5a98b2ba62767edcf72b2abd0ed" id="r_acdc3a5a98b2ba62767edcf72b2abd0ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdc3a5a98b2ba62767edcf72b2abd0ed">MakeParser</a> ()</td></tr>
<tr class="memdesc:acdc3a5a98b2ba62767edcf72b2abd0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the SLR(1) parsing tables (action and transition tables).  <br /></td></tr>
<tr class="memitem:a95d6f1070a535768c6d7f8f953c2b69d" id="r_a95d6f1070a535768c6d7f8f953c2b69d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95d6f1070a535768c6d7f8f953c2b69d">PrintItems</a> (const std::unordered_set&lt; <a class="el" href="structLr0Item.html">Lr0Item</a> &gt; &amp;items) const</td></tr>
<tr class="memdesc:a95d6f1070a535768c6d7f8f953c2b69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of a set of LR(0) items.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aad08331c9b94d48dbdda2e8783ea583a" id="r_aad08331c9b94d48dbdda2e8783ea583a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGrammar.html">Grammar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad08331c9b94d48dbdda2e8783ea583a">gr_</a></td></tr>
<tr class="memdesc:aad08331c9b94d48dbdda2e8783ea583a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The grammar being processed by the parser.  <br /></td></tr>
<tr class="memitem:a4b9b4f88bfef3c3e77f791446f3d820c" id="r_a4b9b4f88bfef3c3e77f791446f3d820c"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::unordered_set&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b9b4f88bfef3c3e77f791446f3d820c">first_sets_</a></td></tr>
<tr class="memdesc:a4b9b4f88bfef3c3e77f791446f3d820c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached FIRST sets for all symbols in the grammar.  <br /></td></tr>
<tr class="memitem:a1412b54cd36ecf31bf48ee0e239d9671" id="r_a1412b54cd36ecf31bf48ee0e239d9671"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::unordered_set&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1412b54cd36ecf31bf48ee0e239d9671">follow_sets_</a></td></tr>
<tr class="memdesc:a1412b54cd36ecf31bf48ee0e239d9671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached FOLLOW sets for all non-terminal symbols in the grammar.  <br /></td></tr>
<tr class="memitem:a55ff1960d521b27fec21ca54d1e3d066" id="r_a55ff1960d521b27fec21ca54d1e3d066"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8eae4c68e04f33947c69190bacd1a3bd">action_table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55ff1960d521b27fec21ca54d1e3d066">actions_</a></td></tr>
<tr class="memdesc:a55ff1960d521b27fec21ca54d1e3d066"><td class="mdescLeft">&#160;</td><td class="mdescRight">The action table used by the parser to determine shift/reduce actions.  <br /></td></tr>
<tr class="memitem:ad91bcfafbf8b58cff15d3c1c7c401bbf" id="r_ad91bcfafbf8b58cff15d3c1c7c401bbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab5eb4bb9299e7fc800a95a23910f5217">transition_table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad91bcfafbf8b58cff15d3c1c7c401bbf">transitions_</a></td></tr>
<tr class="memdesc:ad91bcfafbf8b58cff15d3c1c7c401bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The transition table used by the parser to determine state transitions.  <br /></td></tr>
<tr class="memitem:ad86b57d534785a9863b925619b7e8a12" id="r_ad86b57d534785a9863b925619b7e8a12"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; <a class="el" href="structstate.html">state</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad86b57d534785a9863b925619b7e8a12">states_</a></td></tr>
<tr class="memdesc:ad86b57d534785a9863b925619b7e8a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of states in the parser's state machine.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements an SLR(1) parser for context-free grammars. </p>
<p>This class builds an SLR(1) parsing table and LR(0) automaton from a given grammar. It provides methods for computing closure sets, GOTO transitions, constructing states, and performing syntax analysis using the generated table. </p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a8eae4c68e04f33947c69190bacd1a3bd" name="a8eae4c68e04f33947c69190bacd1a3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eae4c68e04f33947c69190bacd1a3bd">&#9670;&#160;</a></span>action_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8eae4c68e04f33947c69190bacd1a3bd">SLR1Parser::action_table</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">        std::map&lt;unsigned int, std::map&lt;std::string, SLR1Parser::s_action&gt;&gt;</div>
</div><!-- fragment -->
<p>Represents the action table for the SLR(1) parser. </p>
<p>The action table is a map that associates each state and input symbol with a specific action (<span class="tt">Shift</span>, <span class="tt">Reduce</span>, <span class="tt">Accept</span>, or <span class="tt">Empty</span>). It is used to determine the parser's behavior during the parsing process.</p>
<p>The table is structured as:</p><ul>
<li>Outer map: Keys are state IDs (unsigned int).</li>
<li>Inner map: Keys are input symbols (std::string), and values are <span class="tt"><a class="el" href="structSLR1Parser_1_1s__action.html">s_action</a></span> structs representing the action to take. </li>
</ul>

</div>
</div>
<a id="ab5eb4bb9299e7fc800a95a23910f5217" name="ab5eb4bb9299e7fc800a95a23910f5217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5eb4bb9299e7fc800a95a23910f5217">&#9670;&#160;</a></span>transition_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab5eb4bb9299e7fc800a95a23910f5217">SLR1Parser::transition_table</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">        std::map&lt;unsigned int, std::map&lt;std::string, unsigned int&gt;&gt;</div>
</div><!-- fragment -->
<p>Represents the transition table for the SLR(1) parser. </p>
<p>The transition table is a map that associates each state and symbol with the next state to transition to. It is used to guide the parser's state transitions during the parsing process.</p>
<p>The table is structured as:</p><ul>
<li>Outer map: Keys are state IDs (unsigned int).</li>
<li>Inner map: Keys are symbols (std::string), and values are the next state IDs (unsigned int). </li>
</ul>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="ada5e4f3519f68c6b1857742b016c0895" name="ada5e4f3519f68c6b1857742b016c0895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5e4f3519f68c6b1857742b016c0895">&#9670;&#160;</a></span>Action</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ada5e4f3519f68c6b1857742b016c0895">SLR1Parser::Action</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the possible actions in the SLR(1) parsing table. </p>
<p>This enumeration defines the types of actions that can be taken by the parser during the parsing process:</p><ul>
<li><span class="tt">Shift</span>: Shift the input symbol onto the stack and transition to a new state.</li>
<li><span class="tt">Reduce</span>: Reduce a production rule and pop symbols from the stack.</li>
<li><span class="tt">Accept</span>: Accept the input as a valid string in the grammar.</li>
<li><span class="tt">Empty</span>: No action is defined for the current state and input symbol. </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ada5e4f3519f68c6b1857742b016c0895a825a3d98017bab11815ad2817201324c" name="ada5e4f3519f68c6b1857742b016c0895a825a3d98017bab11815ad2817201324c"></a>Shift&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ada5e4f3519f68c6b1857742b016c0895aec4875f03ff0bb0b26cf76ac7f41e3c8" name="ada5e4f3519f68c6b1857742b016c0895aec4875f03ff0bb0b26cf76ac7f41e3c8"></a>Reduce&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ada5e4f3519f68c6b1857742b016c0895ac4408d335012a56ff58937d78050efad" name="ada5e4f3519f68c6b1857742b016c0895ac4408d335012a56ff58937d78050efad"></a>Accept&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ada5e4f3519f68c6b1857742b016c0895ace2c8aed9c2fa0cfbed56cbda4d8bf07" name="ada5e4f3519f68c6b1857742b016c0895ace2c8aed9c2fa0cfbed56cbda4d8bf07"></a>Empty&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af61cf9a5210b5df543a0ffcff96ce295" name="af61cf9a5210b5df543a0ffcff96ce295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61cf9a5210b5df543a0ffcff96ce295">&#9670;&#160;</a></span>SLR1Parser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SLR1Parser::SLR1Parser </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa42411d1cb318041138b476e80aacc9a" name="aa42411d1cb318041138b476e80aacc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42411d1cb318041138b476e80aacc9a">&#9670;&#160;</a></span>SLR1Parser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SLR1Parser::SLR1Parser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGrammar.html">Grammar</a></td>          <td class="paramname"><span class="paramname"><em>gr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_aa42411d1cb318041138b476e80aacc9a_cgraph.png" border="0" usemap="#aclassSLR1Parser_aa42411d1cb318041138b476e80aacc9a_cgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_aa42411d1cb318041138b476e80aacc9a_cgraph" id="aclassSLR1Parser_aa42411d1cb318041138b476e80aacc9a_cgraph">
<area shape="rect" title=" " alt="" coords="5,32,181,60"/>
<area shape="rect" href="classSLR1Parser.html#af0a486daf0c5083b113e557d68732481" title="Computes the FIRST sets for all non&#45;terminal symbols in the grammar." alt="" coords="236,5,452,33"/>
<area shape="poly" title=" " alt="" coords="181,34,220,30,221,35,182,39"/>
<area shape="rect" href="classSLR1Parser.html#a06a9888464cfe48152d72311e25ad79a" title="Computes the FOLLOW sets for all non&#45;terminal symbols in the grammar. The FOLLOW set of a non&#45;termina..." alt="" coords="229,57,460,85"/>
<area shape="poly" title=" " alt="" coords="182,52,213,55,213,61,181,57"/>
<area shape="rect" href="classSLR1Parser.html#a02df38d4f96383ea85d23f56472c57a0" title="Calculates the FIRST set for a given production rule in a grammar." alt="" coords="508,32,637,60"/>
<area shape="poly" title=" " alt="" coords="453,29,493,34,493,39,452,34"/>
<area shape="poly" title=" " alt="" coords="534,33,527,23,532,13,548,7,573,5,599,8,614,14,612,19,598,13,573,11,549,13,536,17,533,23,538,30"/>
<area shape="poly" title=" " alt="" coords="460,56,492,52,492,57,461,61"/>
</map>
</div>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="af1f26efc1c4f8826b2bd1477aa44868b" name="af1f26efc1c4f8826b2bd1477aa44868b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f26efc1c4f8826b2bd1477aa44868b">&#9670;&#160;</a></span>AllItems()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; <a class="el" href="structLr0Item.html">Lr0Item</a> &gt; SLR1Parser::AllItems </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves all LR(0) items in the grammar. This function returns a set of all LR(0) items derived from the grammar's productions. Each LR(0) item represents a production with a marker indicating the current position in the production (e.g., \( A \rightarrow \alpha \bullet \beta \)). </p>
<dl class="section return"><dt>Returns</dt><dd>A set of all LR(0) items in the grammar. </dd></dl>

</div>
</div>
<a id="a0ff2187985600bff50ff8235543d96fb" name="a0ff2187985600bff50ff8235543d96fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff2187985600bff50ff8235543d96fb">&#9670;&#160;</a></span>Closure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SLR1Parser::Closure </td>
          <td>(</td>
          <td class="paramtype">std::unordered_set&lt; <a class="el" href="structLr0Item.html">Lr0Item</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>items</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the closure of a set of LR(0) items. </p>
<p>This function computes the closure of a given set of LR(0) items by adding all items that can be derived from the current items using the grammar's productions. The closure operation ensures that all possible derivations are considered when constructing the parser's states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>The set of LR(0) items for which to compute the closure. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_a0ff2187985600bff50ff8235543d96fb_cgraph.png" border="0" usemap="#aclassSLR1Parser_a0ff2187985600bff50ff8235543d96fb_cgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_a0ff2187985600bff50ff8235543d96fb_cgraph" id="aclassSLR1Parser_a0ff2187985600bff50ff8235543d96fb_cgraph">
<area shape="rect" title="Computes the closure of a set of LR(0) items." alt="" coords="5,29,157,57"/>
<area shape="rect" href="classSLR1Parser.html#a00101890c3c4d2871a8c100209abf122" title="Helper function for computing the closure of LR(0) items." alt="" coords="205,29,379,57"/>
<area shape="poly" title=" " alt="" coords="157,40,189,40,189,46,157,46"/>
<area shape="poly" title=" " alt="" coords="256,30,250,20,254,11,269,5,292,3,317,5,330,12,328,16,315,10,292,8,270,10,258,15,255,20,260,27"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_a0ff2187985600bff50ff8235543d96fb_icgraph.png" border="0" usemap="#aclassSLR1Parser_a0ff2187985600bff50ff8235543d96fb_icgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_a0ff2187985600bff50ff8235543d96fb_icgraph" id="aclassSLR1Parser_a0ff2187985600bff50ff8235543d96fb_icgraph">
<area shape="rect" title="Computes the closure of a set of LR(0) items." alt="" coords="794,57,946,85"/>
<area shape="rect" href="classSLR1Parser.html#aee48bcbf0a93badeb5271a7299cc458b" title="Computes the GOTO transition ( ) for a given set of LR(0) items and a symbol. This function is equiva..." alt="" coords="574,5,711,33"/>
<area shape="poly" title=" " alt="" coords="791,56,706,36,707,31,792,51"/>
<area shape="rect" href="classSLR1Parser.html#a95d3b55554e24aa03f6a73d7b895e78b" title="Creates the initial state of the parser&#39;s state machine." alt="" coords="538,57,746,85"/>
<area shape="poly" title=" " alt="" coords="779,74,747,74,747,68,779,68"/>
<area shape="rect" href="classSLR1Parser.html#acdc3a5a98b2ba62767edcf72b2abd0ed" title="Constructs the SLR(1) parsing tables (action and transition tables)." alt="" coords="312,83,490,110"/>
<area shape="poly" title=" " alt="" coords="797,91,747,99,612,106,490,104,491,99,612,101,746,94,796,86"/>
<area shape="poly" title=" " alt="" coords="523,86,491,90,490,84,522,81"/>
<area shape="rect" href="structGrammarFactory.html#a9d305dd64af208b12d6153e1ab63bc38" title="Generates a SLR(1) random grammar based on the specified difficulty lefel." alt="" coords="5,83,264,110"/>
<area shape="poly" title=" " alt="" coords="296,99,264,99,264,94,296,94"/>
</map>
</div>

</div>
</div>
<a id="a00101890c3c4d2871a8c100209abf122" name="a00101890c3c4d2871a8c100209abf122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00101890c3c4d2871a8c100209abf122">&#9670;&#160;</a></span>ClosureUtil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SLR1Parser::ClosureUtil </td>
          <td>(</td>
          <td class="paramtype">std::unordered_set&lt; <a class="el" href="structLr0Item.html">Lr0Item</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>items</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>visited</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for computing the closure of LR(0) items. </p>
<p>This function recursively computes the closure of a set of LR(0) items by adding items derived from non-terminal symbols. It avoids redundant work by tracking visited non-terminals and stopping when no new items are added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>The set of LR(0) items being processed. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the items set at the start of the current iteration. </td></tr>
    <tr><td class="paramname">visited</td><td>A set of non-terminals that have already been processed. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_a00101890c3c4d2871a8c100209abf122_cgraph.png" border="0" usemap="#aclassSLR1Parser_a00101890c3c4d2871a8c100209abf122_cgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_a00101890c3c4d2871a8c100209abf122_cgraph" id="aclassSLR1Parser_a00101890c3c4d2871a8c100209abf122_cgraph">
<area shape="rect" title="Helper function for computing the closure of LR(0) items." alt="" coords="5,29,180,57"/>
<area shape="poly" title=" " alt="" coords="62,30,57,20,61,11,73,5,93,3,113,5,125,12,122,16,112,10,92,8,75,10,65,15,63,20,67,28"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_a00101890c3c4d2871a8c100209abf122_icgraph.png" border="0" usemap="#aclassSLR1Parser_a00101890c3c4d2871a8c100209abf122_icgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_a00101890c3c4d2871a8c100209abf122_icgraph" id="aclassSLR1Parser_a00101890c3c4d2871a8c100209abf122_icgraph">
<area shape="rect" title="Helper function for computing the closure of LR(0) items." alt="" coords="994,57,1168,85"/>
<area shape="poly" title=" " alt="" coords="1117,44,1104,38,1081,36,1059,38,1047,43,1044,48,1049,55,1045,58,1039,48,1043,39,1058,33,1081,31,1106,33,1119,40"/>
<area shape="rect" href="classSLR1Parser.html#a0ff2187985600bff50ff8235543d96fb" title="Computes the closure of a set of LR(0) items." alt="" coords="794,57,946,85"/>
<area shape="poly" title=" " alt="" coords="978,74,946,74,946,68,978,68"/>
<area shape="rect" href="classSLR1Parser.html#aee48bcbf0a93badeb5271a7299cc458b" title="Computes the GOTO transition ( ) for a given set of LR(0) items and a symbol. This function is equiva..." alt="" coords="574,5,711,33"/>
<area shape="poly" title=" " alt="" coords="791,56,706,36,707,31,792,51"/>
<area shape="rect" href="classSLR1Parser.html#a95d3b55554e24aa03f6a73d7b895e78b" title="Creates the initial state of the parser&#39;s state machine." alt="" coords="538,57,746,85"/>
<area shape="poly" title=" " alt="" coords="779,74,747,74,747,68,779,68"/>
<area shape="rect" href="classSLR1Parser.html#acdc3a5a98b2ba62767edcf72b2abd0ed" title="Constructs the SLR(1) parsing tables (action and transition tables)." alt="" coords="312,83,490,110"/>
<area shape="poly" title=" " alt="" coords="797,91,747,99,612,106,490,104,491,99,612,101,746,94,796,86"/>
<area shape="poly" title=" " alt="" coords="523,86,491,90,490,84,522,81"/>
<area shape="rect" href="structGrammarFactory.html#a9d305dd64af208b12d6153e1ab63bc38" title="Generates a SLR(1) random grammar based on the specified difficulty lefel." alt="" coords="5,83,264,110"/>
<area shape="poly" title=" " alt="" coords="296,99,264,99,264,94,296,94"/>
</map>
</div>

</div>
</div>
<a id="af0a486daf0c5083b113e557d68732481" name="af0a486daf0c5083b113e557d68732481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a486daf0c5083b113e557d68732481">&#9670;&#160;</a></span>ComputeFirstSets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SLR1Parser::ComputeFirstSets </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the FIRST sets for all non-terminal symbols in the grammar. </p>
<p>This function calculates the FIRST set for each non-terminal symbol in the grammar by iteratively applying a least fixed-point algorithm. This approach ensures that the FIRST sets are fully populated by repeatedly expanding and updating the sets until no further changes occur (i.e., a fixed-point is reached). </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_af0a486daf0c5083b113e557d68732481_cgraph.png" border="0" usemap="#aclassSLR1Parser_af0a486daf0c5083b113e557d68732481_cgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_af0a486daf0c5083b113e557d68732481_cgraph" id="aclassSLR1Parser_af0a486daf0c5083b113e557d68732481_cgraph">
<area shape="rect" title="Computes the FIRST sets for all non&#45;terminal symbols in the grammar." alt="" coords="5,29,222,57"/>
<area shape="rect" href="classSLR1Parser.html#a02df38d4f96383ea85d23f56472c57a0" title="Calculates the FIRST set for a given production rule in a grammar." alt="" coords="270,29,399,57"/>
<area shape="poly" title=" " alt="" coords="222,40,254,40,254,46,222,46"/>
<area shape="poly" title=" " alt="" coords="297,30,290,20,295,11,310,5,334,3,360,5,374,12,372,16,359,10,334,8,311,10,299,15,296,20,301,27"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_af0a486daf0c5083b113e557d68732481_icgraph.png" border="0" usemap="#aclassSLR1Parser_af0a486daf0c5083b113e557d68732481_icgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_af0a486daf0c5083b113e557d68732481_icgraph" id="aclassSLR1Parser_af0a486daf0c5083b113e557d68732481_icgraph">
<area shape="rect" title="Computes the FIRST sets for all non&#45;terminal symbols in the grammar." alt="" coords="538,32,754,60"/>
<area shape="rect" href="classSLR1Parser.html#acdc3a5a98b2ba62767edcf72b2abd0ed" title="Constructs the SLR(1) parsing tables (action and transition tables)." alt="" coords="312,5,490,33"/>
<area shape="poly" title=" " alt="" coords="522,35,490,32,491,26,522,30"/>
<area shape="rect" href="classSLR1Parser.html#aa42411d1cb318041138b476e80aacc9a" title=" " alt="" coords="313,57,488,85"/>
<area shape="poly" title=" " alt="" coords="523,61,489,65,489,59,522,56"/>
<area shape="rect" href="structGrammarFactory.html#a9d305dd64af208b12d6153e1ab63bc38" title="Generates a SLR(1) random grammar based on the specified difficulty lefel." alt="" coords="5,5,264,33"/>
<area shape="poly" title=" " alt="" coords="296,22,264,22,264,16,296,16"/>
</map>
</div>

</div>
</div>
<a id="a06a9888464cfe48152d72311e25ad79a" name="a06a9888464cfe48152d72311e25ad79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a9888464cfe48152d72311e25ad79a">&#9670;&#160;</a></span>ComputeFollowSets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SLR1Parser::ComputeFollowSets </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the FOLLOW sets for all non-terminal symbols in the grammar. The FOLLOW set of a non-terminal symbol A contains all terminal symbols that can appear immediately after A in any sentential form derived from the grammar's start symbol. Additionally, if A can be the last symbol in a derivation, the end-of-input marker (<span class="tt">\$</span>) is included in its FOLLOW set. This function computes the FOLLOW sets using the following rules: </p>
<ol type="1">
<li>Initialize FOLLOW(S) = { \(\$\) }, where S is the start symbol.</li>
<li>For each production rule of the form  \(A \rightarrow \alpha B \beta\):<ul>
<li>Add \(FIRST(\beta) \setminus \{\epsilon\}\) to  \(FOLLOW(B)\).</li>
<li>If \(\epsilon \in FIRST(\beta)\), add \(FOLLOW(A)\) to \(FOLLOW(B)\).</li>
</ul>
</li>
<li>Repeat step 2 until no changes occur in any FOLLOW set. The computed FOLLOW sets are cached in the <span class="tt">follow_sets_</span> member variable for later use by the parser. <dl class="section note"><dt>Note</dt><dd>This function assumes that the FIRST sets for all symbols have already been computed and are available in the <span class="tt">first_sets_</span> member variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a02df38d4f96383ea85d23f56472c57a0" title="Calculates the FIRST set for a given production rule in a grammar.">First</a> </dd>
<dd>
<a class="el" href="#a1412b54cd36ecf31bf48ee0e239d9671" title="Cached FOLLOW sets for all non-terminal symbols in the grammar.">follow_sets_</a> </dd></dl>
</li>
</ol>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_a06a9888464cfe48152d72311e25ad79a_cgraph.png" border="0" usemap="#aclassSLR1Parser_a06a9888464cfe48152d72311e25ad79a_cgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_a06a9888464cfe48152d72311e25ad79a_cgraph" id="aclassSLR1Parser_a06a9888464cfe48152d72311e25ad79a_cgraph">
<area shape="rect" title="Computes the FOLLOW sets for all non&#45;terminal symbols in the grammar. The FOLLOW set of a non&#45;termina..." alt="" coords="5,29,237,57"/>
<area shape="rect" href="classSLR1Parser.html#a02df38d4f96383ea85d23f56472c57a0" title="Calculates the FIRST set for a given production rule in a grammar." alt="" coords="285,29,414,57"/>
<area shape="poly" title=" " alt="" coords="237,40,269,40,269,46,237,46"/>
<area shape="poly" title=" " alt="" coords="310,30,304,20,309,11,324,5,349,3,376,5,391,12,388,16,375,10,349,8,326,10,312,15,309,20,315,27"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_a06a9888464cfe48152d72311e25ad79a_icgraph.png" border="0" usemap="#aclassSLR1Parser_a06a9888464cfe48152d72311e25ad79a_icgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_a06a9888464cfe48152d72311e25ad79a_icgraph" id="aclassSLR1Parser_a06a9888464cfe48152d72311e25ad79a_icgraph">
<area shape="rect" title="Computes the FOLLOW sets for all non&#45;terminal symbols in the grammar. The FOLLOW set of a non&#45;termina..." alt="" coords="538,32,769,60"/>
<area shape="rect" href="classSLR1Parser.html#acdc3a5a98b2ba62767edcf72b2abd0ed" title="Constructs the SLR(1) parsing tables (action and transition tables)." alt="" coords="312,5,490,33"/>
<area shape="poly" title=" " alt="" coords="522,35,490,31,491,26,523,29"/>
<area shape="rect" href="classSLR1Parser.html#aa42411d1cb318041138b476e80aacc9a" title=" " alt="" coords="313,57,488,85"/>
<area shape="poly" title=" " alt="" coords="523,62,489,65,489,60,522,56"/>
<area shape="rect" href="structGrammarFactory.html#a9d305dd64af208b12d6153e1ab63bc38" title="Generates a SLR(1) random grammar based on the specified difficulty lefel." alt="" coords="5,5,264,33"/>
<area shape="poly" title=" " alt="" coords="296,22,264,22,264,16,296,16"/>
</map>
</div>

</div>
</div>
<a id="aee48bcbf0a93badeb5271a7299cc458b" name="aee48bcbf0a93badeb5271a7299cc458b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee48bcbf0a93badeb5271a7299cc458b">&#9670;&#160;</a></span>Delta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; <a class="el" href="structLr0Item.html">Lr0Item</a> &gt; SLR1Parser::Delta </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="structLr0Item.html">Lr0Item</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>items</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the GOTO transition ( \(\delta\)) for a given set of LR(0) items and a symbol. This function is equivalent to the \(\delta(I, X)\) function in LR parsing, where it computes the set of items reached from a state \(I\) via symbol \(X\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>The current set of LR(0) items (state). </td></tr>
    <tr><td class="paramname">str</td><td>The grammar symbol used for the transition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting item set after the GOTO transition. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_aee48bcbf0a93badeb5271a7299cc458b_cgraph.png" border="0" usemap="#aclassSLR1Parser_aee48bcbf0a93badeb5271a7299cc458b_cgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_aee48bcbf0a93badeb5271a7299cc458b_cgraph" id="aclassSLR1Parser_aee48bcbf0a93badeb5271a7299cc458b_cgraph">
<area shape="rect" title="Computes the GOTO transition ( ) for a given set of LR(0) items and a symbol. This function is equiva..." alt="" coords="5,56,143,84"/>
<area shape="rect" href="classSLR1Parser.html#a0ff2187985600bff50ff8235543d96fb" title="Computes the closure of a set of LR(0) items." alt="" coords="191,29,342,57"/>
<area shape="poly" title=" " alt="" coords="143,58,175,53,176,58,144,63"/>
<area shape="rect" href="structLr0Item.html#a485ab0289f3353b47ea38dcee418a0b6" title="Returns the symbol immediately after the dot, or empty if the dot is at the end." alt="" coords="193,81,340,109"/>
<area shape="poly" title=" " alt="" coords="144,76,178,81,177,86,143,82"/>
<area shape="rect" href="classSLR1Parser.html#a00101890c3c4d2871a8c100209abf122" title="Helper function for computing the closure of LR(0) items." alt="" coords="390,29,564,57"/>
<area shape="poly" title=" " alt="" coords="342,40,374,40,374,46,342,46"/>
<area shape="poly" title=" " alt="" coords="441,30,435,20,440,11,454,5,477,3,502,5,515,12,513,16,501,10,477,8,455,10,443,15,440,20,445,27"/>
</map>
</div>

</div>
</div>
<a id="a02df38d4f96383ea85d23f56472c57a0" name="a02df38d4f96383ea85d23f56472c57a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02df38d4f96383ea85d23f56472c57a0">&#9670;&#160;</a></span>First()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SLR1Parser::First </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>rule</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the FIRST set for a given production rule in a grammar. </p>
<p>The FIRST set of a production rule contains all terminal symbols that can appear at the beginning of any string derived from that rule. If the rule can derive the empty string (epsilon), epsilon is included in the FIRST set.</p>
<p>This function computes the FIRST set by examining each symbol in the production rule:</p><ul>
<li>If a terminal symbol is encountered, it is added directly to the FIRST set, as it is the starting symbol of some derivation.</li>
<li>If a non-terminal symbol is encountered, its FIRST set is recursively computed and added to the result, excluding epsilon unless it is followed by another symbol that could also lead to epsilon.</li>
<li>If the entire rule could derive epsilon (i.e., each symbol in the rule can derive epsilon), then epsilon is added to the FIRST set.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rule</td><td>A span of strings representing the production rule for which to compute the FIRST set. Each string in the span is a symbol (either terminal or non-terminal). </td></tr>
    <tr><td class="paramname">result</td><td>A reference to an unordered set of strings where the computed FIRST set will be stored. The set will contain all terminal symbols that can start derivations of the rule, and possibly epsilon if the rule can derive an empty string. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_a02df38d4f96383ea85d23f56472c57a0_cgraph.png" border="0" usemap="#aclassSLR1Parser_a02df38d4f96383ea85d23f56472c57a0_cgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_a02df38d4f96383ea85d23f56472c57a0_cgraph" id="aclassSLR1Parser_a02df38d4f96383ea85d23f56472c57a0_cgraph">
<area shape="rect" title="Calculates the FIRST set for a given production rule in a grammar." alt="" coords="5,29,135,57"/>
<area shape="poly" title=" " alt="" coords="47,30,43,20,46,11,55,5,70,3,86,5,94,11,91,16,83,10,70,8,57,10,50,14,48,20,52,28"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_a02df38d4f96383ea85d23f56472c57a0_icgraph.png" border="0" usemap="#aclassSLR1Parser_a02df38d4f96383ea85d23f56472c57a0_icgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_a02df38d4f96383ea85d23f56472c57a0_icgraph" id="aclassSLR1Parser_a02df38d4f96383ea85d23f56472c57a0_icgraph">
<area shape="rect" title="Calculates the FIRST set for a given production rule in a grammar." alt="" coords="817,32,947,60"/>
<area shape="poly" title=" " alt="" coords="921,19,907,13,882,11,858,13,845,17,842,23,847,30,843,33,837,23,842,13,857,7,882,5,909,8,923,14"/>
<area shape="rect" href="classSLR1Parser.html#af0a486daf0c5083b113e557d68732481" title="Computes the FIRST sets for all non&#45;terminal symbols in the grammar." alt="" coords="546,5,762,33"/>
<area shape="poly" title=" " alt="" coords="802,39,762,35,763,29,802,34"/>
<area shape="rect" href="classSLR1Parser.html#a06a9888464cfe48152d72311e25ad79a" title="Computes the FOLLOW sets for all non&#45;terminal symbols in the grammar. The FOLLOW set of a non&#45;termina..." alt="" coords="538,57,769,85"/>
<area shape="poly" title=" " alt="" coords="802,57,770,61,769,56,802,52"/>
<area shape="rect" href="classSLR1Parser.html#acdc3a5a98b2ba62767edcf72b2abd0ed" title="Constructs the SLR(1) parsing tables (action and transition tables)." alt="" coords="312,5,490,33"/>
<area shape="poly" title=" " alt="" coords="530,22,490,22,490,16,530,16"/>
<area shape="rect" href="classSLR1Parser.html#aa42411d1cb318041138b476e80aacc9a" title=" " alt="" coords="313,57,488,85"/>
<area shape="poly" title=" " alt="" coords="568,39,472,59,471,54,567,34"/>
<area shape="rect" href="structGrammarFactory.html#a9d305dd64af208b12d6153e1ab63bc38" title="Generates a SLR(1) random grammar based on the specified difficulty lefel." alt="" coords="5,5,264,33"/>
<area shape="poly" title=" " alt="" coords="296,22,264,22,264,16,296,16"/>
<area shape="poly" title=" " alt="" coords="567,56,471,36,472,31,568,51"/>
<area shape="poly" title=" " alt="" coords="522,74,489,74,489,68,522,68"/>
</map>
</div>

</div>
</div>
<a id="af2549ef0375afbb8fd53fa2abafe60bb" name="af2549ef0375afbb8fd53fa2abafe60bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2549ef0375afbb8fd53fa2abafe60bb">&#9670;&#160;</a></span>Follow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; std::string &gt; SLR1Parser::Follow </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the FOLLOW set for a given non-terminal symbol in the grammar. </p>
<p>The FOLLOW set for a non-terminal symbol includes all symbols that can appear immediately to the right of that symbol in any derivation, as well as any end-of-input markers if the symbol can appear at the end of derivations. FOLLOW sets are used in LL(1) parsing table construction to determine possible continuations after a non-terminal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Non-terminal symbol for which to compute the FOLLOW set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unordered set of strings containing symbols that form the FOLLOW set for <span class="tt">arg</span>. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_af2549ef0375afbb8fd53fa2abafe60bb_icgraph.png" border="0" usemap="#aclassSLR1Parser_af2549ef0375afbb8fd53fa2abafe60bb_icgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_af2549ef0375afbb8fd53fa2abafe60bb_icgraph" id="aclassSLR1Parser_af2549ef0375afbb8fd53fa2abafe60bb_icgraph">
<area shape="rect" title="Computes the FOLLOW set for a given non&#45;terminal symbol in the grammar." alt="" coords="265,32,409,60"/>
<area shape="rect" href="classSLRWizard.html#a1833672694f25771c1b66c4e2b935610" title="Constructs the SLR(1) wizard with all necessary parsing context." alt="" coords="27,5,195,33"/>
<area shape="poly" title=" " alt="" coords="249,38,195,32,196,26,249,33"/>
<area shape="rect" href="classSLR1Parser.html#a6a31a57223b052028c74f5d70db41c16" title="Resolves LR conflicts in a given state." alt="" coords="5,57,217,85"/>
<area shape="poly" title=" " alt="" coords="249,58,217,62,217,57,249,53"/>
</map>
</div>

</div>
</div>
<a id="a95d3b55554e24aa03f6a73d7b895e78b" name="a95d3b55554e24aa03f6a73d7b895e78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d3b55554e24aa03f6a73d7b895e78b">&#9670;&#160;</a></span>MakeInitialState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SLR1Parser::MakeInitialState </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the initial state of the parser's state machine. </p>
<p>This function initializes the starting state of the parser by computing the closure of the initial set of LR(0) items derived from the grammar's start symbol. The initial state is added to the <span class="tt">states_</span> set, and its transitions are prepared for further processing in the parser construction.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad86b57d534785a9863b925619b7e8a12" title="The set of states in the parser&#39;s state machine.">states_</a> </dd>
<dd>
<a class="el" href="#ad91bcfafbf8b58cff15d3c1c7c401bbf" title="The transition table used by the parser to determine state transitions.">transitions_</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_a95d3b55554e24aa03f6a73d7b895e78b_cgraph.png" border="0" usemap="#aclassSLR1Parser_a95d3b55554e24aa03f6a73d7b895e78b_cgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_a95d3b55554e24aa03f6a73d7b895e78b_cgraph" id="aclassSLR1Parser_a95d3b55554e24aa03f6a73d7b895e78b_cgraph">
<area shape="rect" title="Creates the initial state of the parser&#39;s state machine." alt="" coords="5,29,214,57"/>
<area shape="rect" href="classSLR1Parser.html#a0ff2187985600bff50ff8235543d96fb" title="Computes the closure of a set of LR(0) items." alt="" coords="262,29,413,57"/>
<area shape="poly" title=" " alt="" coords="214,40,246,40,246,46,214,46"/>
<area shape="rect" href="classSLR1Parser.html#a00101890c3c4d2871a8c100209abf122" title="Helper function for computing the closure of LR(0) items." alt="" coords="461,29,635,57"/>
<area shape="poly" title=" " alt="" coords="413,40,445,40,445,46,413,46"/>
<area shape="poly" title=" " alt="" coords="512,30,506,20,511,11,525,5,548,3,573,5,586,12,584,16,572,10,548,8,526,10,514,15,511,20,516,27"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_a95d3b55554e24aa03f6a73d7b895e78b_icgraph.png" border="0" usemap="#aclassSLR1Parser_a95d3b55554e24aa03f6a73d7b895e78b_icgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_a95d3b55554e24aa03f6a73d7b895e78b_icgraph" id="aclassSLR1Parser_a95d3b55554e24aa03f6a73d7b895e78b_icgraph">
<area shape="rect" title="Creates the initial state of the parser&#39;s state machine." alt="" coords="538,5,746,33"/>
<area shape="rect" href="classSLR1Parser.html#acdc3a5a98b2ba62767edcf72b2abd0ed" title="Constructs the SLR(1) parsing tables (action and transition tables)." alt="" coords="312,5,490,33"/>
<area shape="poly" title=" " alt="" coords="522,22,491,22,491,16,522,16"/>
<area shape="rect" href="structGrammarFactory.html#a9d305dd64af208b12d6153e1ab63bc38" title="Generates a SLR(1) random grammar based on the specified difficulty lefel." alt="" coords="5,5,264,33"/>
<area shape="poly" title=" " alt="" coords="296,22,264,22,264,16,296,16"/>
</map>
</div>

</div>
</div>
<a id="acdc3a5a98b2ba62767edcf72b2abd0ed" name="acdc3a5a98b2ba62767edcf72b2abd0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc3a5a98b2ba62767edcf72b2abd0ed">&#9670;&#160;</a></span>MakeParser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SLR1Parser::MakeParser </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the SLR(1) parsing tables (action and transition tables). </p>
<p>This function builds the SLR(1) parsing tables by computing the canonical collection of LR(0) items, generating the action and transition tables, and resolving conflicts (if any). It returns <span class="tt">true</span> if the grammar is SLR(1) and the tables are successfully constructed, or <span class="tt">false</span> if a conflict is detected that cannot be resolved.</p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the parsing tables are successfully constructed, <span class="tt">false</span> if the grammar is not SLR(1) or a conflict is encountered.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a55ff1960d521b27fec21ca54d1e3d066" title="The action table used by the parser to determine shift/reduce actions.">actions_</a> </dd>
<dd>
<a class="el" href="#ad91bcfafbf8b58cff15d3c1c7c401bbf" title="The transition table used by the parser to determine state transitions.">transitions_</a> </dd>
<dd>
<a class="el" href="#ad86b57d534785a9863b925619b7e8a12" title="The set of states in the parser&#39;s state machine.">states_</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_acdc3a5a98b2ba62767edcf72b2abd0ed_cgraph.png" border="0" usemap="#aclassSLR1Parser_acdc3a5a98b2ba62767edcf72b2abd0ed_cgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_acdc3a5a98b2ba62767edcf72b2abd0ed_cgraph" id="aclassSLR1Parser_acdc3a5a98b2ba62767edcf72b2abd0ed_cgraph">
<area shape="rect" title="Constructs the SLR(1) parsing tables (action and transition tables)." alt="" coords="5,107,184,134"/>
<area shape="rect" href="structLr0Item.html#ac342e279b0a266a84f984b82604532e6" title="Advances the dot one position to the right." alt="" coords="268,5,426,33"/>
<area shape="poly" title=" " alt="" coords="119,104,170,77,231,49,271,35,272,40,233,54,172,81,121,109"/>
<area shape="rect" href="classSLR1Parser.html#a0ff2187985600bff50ff8235543d96fb" title="Computes the closure of a set of LR(0) items." alt="" coords="511,88,662,116"/>
<area shape="poly" title=" " alt="" coords="160,103,231,93,296,88,347,88,463,93,496,94,496,99,463,98,347,93,297,93,232,98,160,109"/>
<area shape="rect" href="classSLR1Parser.html#af0a486daf0c5083b113e557d68732481" title="Computes the FIRST sets for all non&#45;terminal symbols in the grammar." alt="" coords="239,159,456,186"/>
<area shape="poly" title=" " alt="" coords="166,132,262,152,261,158,165,138"/>
<area shape="rect" href="classSLR1Parser.html#a06a9888464cfe48152d72311e25ad79a" title="Computes the FOLLOW sets for all non&#45;terminal symbols in the grammar. The FOLLOW set of a non&#45;termina..." alt="" coords="232,211,463,238"/>
<area shape="poly" title=" " alt="" coords="118,133,169,164,233,195,256,203,255,208,231,200,166,169,115,137"/>
<area shape="rect" href="classSLR1Parser.html#a95d3b55554e24aa03f6a73d7b895e78b" title="Creates the initial state of the parser&#39;s state machine." alt="" coords="243,107,452,134"/>
<area shape="poly" title=" " alt="" coords="184,118,228,118,228,123,184,123"/>
<area shape="rect" href="classSLR1Parser.html#a00101890c3c4d2871a8c100209abf122" title="Helper function for computing the closure of LR(0) items." alt="" coords="710,88,885,116"/>
<area shape="poly" title=" " alt="" coords="663,99,695,99,695,104,663,104"/>
<area shape="poly" title=" " alt="" coords="761,89,755,79,760,69,774,63,798,61,822,64,836,70,833,75,821,69,797,67,776,69,764,73,761,79,766,86"/>
<area shape="rect" href="classSLR1Parser.html#a02df38d4f96383ea85d23f56472c57a0" title="Calculates the FIRST set for a given production rule in a grammar." alt="" coords="522,177,651,205"/>
<area shape="poly" title=" " alt="" coords="456,178,507,182,506,188,456,184"/>
<area shape="poly" title=" " alt="" coords="550,178,545,168,549,159,564,153,587,151,612,153,625,160,623,164,610,158,587,156,565,158,553,163,550,168,555,175"/>
<area shape="poly" title=" " alt="" coords="451,207,506,200,507,205,452,213"/>
<area shape="poly" title=" " alt="" coords="452,110,495,106,496,112,452,115"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_acdc3a5a98b2ba62767edcf72b2abd0ed_icgraph.png" border="0" usemap="#aclassSLR1Parser_acdc3a5a98b2ba62767edcf72b2abd0ed_icgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_acdc3a5a98b2ba62767edcf72b2abd0ed_icgraph" id="aclassSLR1Parser_acdc3a5a98b2ba62767edcf72b2abd0ed_icgraph">
<area shape="rect" title="Constructs the SLR(1) parsing tables (action and transition tables)." alt="" coords="312,5,490,33"/>
<area shape="rect" href="structGrammarFactory.html#a9d305dd64af208b12d6153e1ab63bc38" title="Generates a SLR(1) random grammar based on the specified difficulty lefel." alt="" coords="5,5,264,33"/>
<area shape="poly" title=" " alt="" coords="296,22,264,22,264,16,296,16"/>
</map>
</div>

</div>
</div>
<a id="a95d6f1070a535768c6d7f8f953c2b69d" name="a95d6f1070a535768c6d7f8f953c2b69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d6f1070a535768c6d7f8f953c2b69d">&#9670;&#160;</a></span>PrintItems()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SLR1Parser::PrintItems </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="structLr0Item.html">Lr0Item</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>items</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of a set of LR(0) items. </p>
<p>This function converts a set of LR(0) items into a human-readable string, including dot positions, to help visualize parser states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>The set of LR(0) items to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A formatted string representation of the items. </dd></dl>

</div>
</div>
<a id="a6a31a57223b052028c74f5d70db41c16" name="a6a31a57223b052028c74f5d70db41c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a31a57223b052028c74f5d70db41c16">&#9670;&#160;</a></span>SolveLRConflicts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SLR1Parser::SolveLRConflicts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstate.html">state</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>st</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolves LR conflicts in a given state. </p>
<p>This function attempts to resolve shift/reduce or reduce/reduce conflicts in a given state using SLR(1) parsing rules. It checks the FOLLOW sets of non-terminals to determine the correct action and updates the action table accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>The state in which to resolve conflicts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if all conflicts are resolved, <span class="tt">false</span> if an unresolvable conflict is detected. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSLR1Parser_a6a31a57223b052028c74f5d70db41c16_cgraph.png" border="0" usemap="#aclassSLR1Parser_a6a31a57223b052028c74f5d70db41c16_cgraph" loading="lazy" alt=""/></div>
<map name="aclassSLR1Parser_a6a31a57223b052028c74f5d70db41c16_cgraph" id="aclassSLR1Parser_a6a31a57223b052028c74f5d70db41c16_cgraph">
<area shape="rect" title="Resolves LR conflicts in a given state." alt="" coords="5,57,217,85"/>
<area shape="rect" href="classSLR1Parser.html#af2549ef0375afbb8fd53fa2abafe60bb" title="Computes the FOLLOW set for a given non&#45;terminal symbol in the grammar." alt="" coords="269,5,414,33"/>
<area shape="poly" title=" " alt="" coords="175,54,261,34,262,40,176,59"/>
<area shape="rect" href="structLr0Item.html#a4db23e1d025750a6ca817aa4998a03f4" title="Checks whether the dot has reached the end of the production." alt="" coords="265,57,418,85"/>
<area shape="poly" title=" " alt="" coords="217,68,249,68,249,74,217,74"/>
<area shape="rect" href="structLr0Item.html#a485ab0289f3353b47ea38dcee418a0b6" title="Returns the symbol immediately after the dot, or empty if the dot is at the end." alt="" coords="268,109,415,137"/>
<area shape="poly" title=" " alt="" coords="176,83,262,103,261,108,175,88"/>
</map>
</div>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a55ff1960d521b27fec21ca54d1e3d066" name="a55ff1960d521b27fec21ca54d1e3d066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ff1960d521b27fec21ca54d1e3d066">&#9670;&#160;</a></span>actions_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8eae4c68e04f33947c69190bacd1a3bd">action_table</a> SLR1Parser::actions_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The action table used by the parser to determine shift/reduce actions. </p>

</div>
</div>
<a id="a4b9b4f88bfef3c3e77f791446f3d820c" name="a4b9b4f88bfef3c3e77f791446f3d820c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9b4f88bfef3c3e77f791446f3d820c">&#9670;&#160;</a></span>first_sets_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, std::unordered_set&lt;std::string&gt; &gt; SLR1Parser::first_sets_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached FIRST sets for all symbols in the grammar. </p>

</div>
</div>
<a id="a1412b54cd36ecf31bf48ee0e239d9671" name="a1412b54cd36ecf31bf48ee0e239d9671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1412b54cd36ecf31bf48ee0e239d9671">&#9670;&#160;</a></span>follow_sets_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, std::unordered_set&lt;std::string&gt; &gt; SLR1Parser::follow_sets_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cached FOLLOW sets for all non-terminal symbols in the grammar. </p>

</div>
</div>
<a id="aad08331c9b94d48dbdda2e8783ea583a" name="aad08331c9b94d48dbdda2e8783ea583a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad08331c9b94d48dbdda2e8783ea583a">&#9670;&#160;</a></span>gr_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGrammar.html">Grammar</a> SLR1Parser::gr_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The grammar being processed by the parser. </p>

</div>
</div>
<a id="ad86b57d534785a9863b925619b7e8a12" name="ad86b57d534785a9863b925619b7e8a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86b57d534785a9863b925619b7e8a12">&#9670;&#160;</a></span>states_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt;<a class="el" href="structstate.html">state</a>&gt; SLR1Parser::states_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The set of states in the parser's state machine. </p>

</div>
</div>
<a id="ad91bcfafbf8b58cff15d3c1c7c401bbf" name="ad91bcfafbf8b58cff15d3c1c7c401bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91bcfafbf8b58cff15d3c1c7c401bbf">&#9670;&#160;</a></span>transitions_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab5eb4bb9299e7fc800a95a23910f5217">transition_table</a> SLR1Parser::transitions_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The transition table used by the parser to determine state transitions. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>backend/<a class="el" href="slr1__parser_8hpp_source.html">slr1_parser.hpp</a></li>
<li>backend/<a class="el" href="slr1__parser_8cpp.html">slr1_parser.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="classSLR1Parser.html">SLR1Parser</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
